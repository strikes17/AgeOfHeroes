[Exception] IndexOutOfRangeException: Index was outside the bounds of the array.
FogOfWarObject.GetCell() at /Scripts/Visuals/FogOfWarObject.cs:54
46:           public void SetCell(Vector2Int position, FogOfWarCellType fogOfWarCellType)
47:           {
48:               if (position.x >= sizeX || position.y >= sizeY) return;
49:               _fogMap[position.x, position.y] = (byte)fogOfWarCellType;
50:           }
52:           public FogOfWarCellType GetCell(Vector2Int position)
53:           {
-->54:               return (FogOfWarCellType)_fogMap[position.x, position.y];
55:           }
56:       }
57:   }

PlayerFogOfWarController.IsCharacterInsideFogOfWar() at /Scripts/Visuals/PlayerFogOfWarController.cs:87
79:       return fogOfWarObject.GetCell(new Vector2Int(position.x, position.y));
80:   }
82:   public bool IsCharacterInsideFogOfWar(ControllableCharacter character)
83:   {
84:       var terrain = character.PlayableTerrain;
85:       var fogOfWarObject = GetFogOfWarObject(terrain.UniqueId);
86:       var pos = new Vector2Int(character.Position.x, character.Position.y);
-->87:       bool insideFog = fogOfWarObject.GetCell(pos) != FogOfWarCellType.Clear;
88:       return insideFog;
89:   }
91:   public void UpdateVisionAtAreaForPlayer(Player player, Vector2Int center, PlayableTerrain terrain, int radius,
92:       bool ignoreHighObstacles = false,
93:       bool unrevealFog = false)
94:   {
95:       var newOpenedFogOfWarCells = CollectFogCellsAround(center, terrain, radius);

ControllableCharacter.IsVisibleForPlayer() at /Scripts/GamePlay/ControllableCharacter.cs:334
327:   public virtual void VisuallyShow()
328:   {
329:       _spriteRenderer.enabled = true;
330:   }
332:   public bool IsVisibleForPlayer(Player player)
333:   {
-->334:       bool isInsideTheFog = player.fogOfWarController.IsCharacterInsideFogOfWar(this);
335:       return !isInsideTheFog;
336:   }
338:   public Player Player
339:   {
340:       get => GameManager.Instance.MapScenarioHandler.players[playerOwnerColor];
341:   }

Player.UpdateVisionForEveryEnemy() at /Scripts/GamePlay/Player.cs:517
509:   var allPlayer = GameManager.Instance.MapScenarioHandler.AllPlayers;
510:   foreach (var player in allPlayer)
511:   {
512:       if (player == this) continue;
513:       var enemies = player.controlledCharacters;
514:       for (int i = 0; i < enemies.Count; i++)
515:       {
516:           var enemy = enemies[i];
-->517:           if (enemy.IsVisibleForPlayer(this))
518:           {
519:               enemy.VisuallyShow();
520:           }
521:           else
522:           {
523:               enemy.VisuallyHide();
524:           }
525:       }

PlayerHuman.OnPlayerRecievedTurn() at /Scripts/GamePlay/PlayerHuman.cs:26
18:       _guiLeftSidebar.Closed += () => SetActiveContext(PlayerContext.Default);
19:   }
21:   public override void OnPlayerRecievedTurn()
22:   {
23:       base.OnPlayerRecievedTurn();
24:       _GUIManager.skipTurnButton.Unlock();
25:       EnableInteractionWithWorld();
-->26:       UpdateVisionForEveryEnemy();
27:       _fogOfWarController.ShowFogOfWarForTerrain(ActiveTerrain);
28:   }
30:   public override void OnEnemyCastleSiegePlanningStage(CastleSiegeData siegeData)
31:   {
32:       base.OnEnemyCastleSiegePlanningStage(siegeData);
33:       SetupSiegePanel(siegeData.attackingPlayer, siegeData.attackingCharacters, siegeData.siegedCastleTerrain);
34:   }

MapScenarioHandler.GivePlayerTurn() at /Scripts/Systems/MapScenarioHandler.cs:218
210:           float speed = Random.Range(0.25f, 1f);
211:           CloudDecoration.Create(offset)
212:               .Float(Vector2.right, GameManager.Instance.WorldTerrain.Size, speed);
213:       }
214:   }
216:   private void GivePlayerTurn(Player player)
217:   {
-->218:       player.OnPlayerRecievedTurn();
219:   }
222:   public void SkipPlayerTurn()
223:   {
224:       turnsCountThisDay++;
225:       if (turnsCountThisDay >= TotalPlayersCountWithNeutral)
226:       {

MapScenarioHandler.<NewGameInitialization>b__56_0() at /Scripts/Systems/MapScenarioHandler.cs:198
190:       turnOfPlayerId = (PlayerColor)_firstHumanPlayerIndex;
191:       Debug.Log(turnOfPlayerId);
192:       var spawnManager = GameManager.Instance.SpawnManager;
193:       var navManager = GameManager.Instance.terrainManager;
194:       GameManager.Instance.terrainManager.EntitiesReady += terrain =>
195:       {
196:           gameStarted?.Invoke();
197:           OnNewDayBegin();
-->198:           GivePlayerTurn(players[turnOfPlayerId]);
199:           GameManager.Instance.GUIManager.OnSwitchTurnUpdateGUI(turnOfPlayerId);
200:           __Clouds();
201:       };
202:   }
204:   private void __Clouds()
205:   {
206:       var size = GameManager.Instance.WorldTerrain.Size;

TerrainManager.LoadEntities() at /Scripts/Systems/TerrainManager.cs:204
196:       var serializableArtifacts = serializablePlayableTerrain.SerializableArtifacts;
197:       foreach (var serializableArtifact in serializableArtifacts)
198:       {
199:           var artifactObject = ResourcesBase.GetArtifactObject(serializableArtifact.artifactObjectName);
200:           Vector3Int position = new Vector3Int(serializableArtifact.positionX, serializableArtifact.positionY, 0);
201:           spawnManager.SpawnArtifact(artifactObject, position, playableTerrain);
202:       }
-->204:       _entitiesReady?.Invoke(playableTerrain);
205:   }
207:   private PlayableTerrain LoadTerrain(SerializablePlayableTerrain map, Vector2Int mapSize)
208:   {
209:       var tilemapGridRefs = GameObject.Instantiate(_mapTileMapGridPrefab, Vector3.zero, Quaternion.identity)
210:           .GetComponent<MapTilemapGridReferences>();
211:       tilemapGridRefs.gameObject.SetActive(false);
212:       tilemapGridRefs.name = map.MapInfo.Name;

TerrainManager+<>c__DisplayClass25_1.<LoadWorldMap>b__1() at /Scripts/Systems/TerrainManager.cs:109
101:           worldTerrain.MapTilemapGridReferences.gameObject.SetActive(true);
102:           _currentPlayableMap.WorldTerrain = worldTerrain;
103:           var mapCollisions = serializedTerrain.Collisions;
104:           worldTerrain.TerrainNavigator.CreateNavigationMap(worldTerrain, mapCollisions);
105:           CreateCastlesTerrains(serializedTerrain, worldTerrain, () =>
106:           {
107:               SpawnFogOfWar();
108:               _worldTerrainReady?.Invoke(worldTerrain);
-->109:               LoadEntities(serializedTerrain, worldTerrain);
110:           });
111:       }, matchInfo.MapInfo.MapCategory));
112:       return this;
113:   }
115:   private void SpawnFogOfWar()
116:   {
117:       var fogsOfWarRootTransform = new GameObject($"__fog_of_war_").transform;

TerrainManager+<>c__DisplayClass27_1.<CreateCastlesTerrains>b__1() at /Scripts/Systems/TerrainManager.cs:154
146:               {
147:                   if (player.Value.Color == PlayerColor.Neutral) continue;
148:                   player.Value.fogOfWarController.InitCastleTerrainFog(player.Value, terrain);
149:               }
151:               castlesIndexer++;
152:               if (castlesIndexer >= playableTerrain.SpawnedCastles.Count)
153:               {
-->154:                   onCastlesTerrainsReady.Invoke();
155:               }
156:           });
157:       });
158:   }
160:   private void LoadEntities(SerializablePlayableTerrain serializablePlayableTerrain,
161:       PlayableTerrain playableTerrain)
162:   {

TerrainManager+<>c__DisplayClass24_0.<LoadCastleTerrain>b__0() at /Scripts/Systems/TerrainManager.cs:89
81:       Moroutine.Run(MapSerializerSystem.MapSerializer.LoadInternalMap(mapName, serializedTerrain =>
82:       {
83:           var loadedTerrain = LoadTerrain(serializedTerrain, new Vector2Int(serializedTerrain
84:               .MapInfo.sizeX, serializedTerrain
85:               .MapInfo.sizeY));
86:           _currentPlayableMap.CastlesTerrains.TryAdd(castle, loadedTerrain);
87:           var mapCollisions = serializedTerrain.Collisions;
88:           loadedTerrain.TerrainNavigator.CreateNavigationMap(loadedTerrain, mapCollisions);
-->89:           onPlayableTerrainReady?.Invoke(loadedTerrain);
90:       }));
91:   }
93:   public TerrainManager LoadWorldMap(MatchInfo matchInfo)
94:   {
95:       _currentPlayableMap = new PlayableMap();
96:       var mapSize = new Vector2Int(matchInfo.MapInfo.sizeX, matchInfo.MapInfo.sizeY);
97:       var mapFileName = matchInfo.MapInfo.Name;

MapSerializerSystem+<>c__DisplayClass4_0.<LoadInternalMap>b__0() at /Scripts/Systems/MapSerializerSystem.cs:49
41:       var mapResourcesPath = $"Internal Maps/{mapName}";
42:       var loadAsync = Resources.LoadAsync(mapResourcesPath, typeof(TextAsset));
43:       loadAsync.completed += (operation) =>
44:       {
45:           var mapFileContents = loadAsync.asset as TextAsset;
46:           var jsonObject =
47:               JsonConvert.DeserializeObject<SerializablePlayableTerrain>(mapFileContents.text,
48:                   jsonSerializerSettings);
-->49:           onMapLoaded.Invoke(jsonObject);
50:       };
51:       yield return null;
52:   }
54:   public IEnumerator LoadMap(string mapName, Action<SerializablePlayableTerrain> onMapLoaded,
55:       MapCategory mapCategory = MapCategory.Original)
56:   {
57:       var mapFullPath = string.Empty;

AsyncOperation.InvokeCompletionEvent() at <f7bcd9bfa40c4821acdda68a85850616>:0
